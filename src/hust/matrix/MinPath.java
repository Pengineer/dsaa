package hust.matrix;

/**
 * 矩阵的最小路径和（动态规划）
 * 题目：
 * 给定一个矩阵m，从左上角开始每次只能向右或者向下走，最后到达右下角位置，路径上所有的数字累加起来就是路径和，返回所有路径中最小的路径和。
 * 举例：
 * 如果给定的m如下：
 * 1  3  5  9
 * 8  1  3  4
 * 5  0  6  1
 * 8  8  4  0
 * 解答一：
 * 经典动态规划方法。假设矩阵大小为M*N，行数为M，列数为N。先生成大小和m一样的矩阵dp，dp[i][j]的值表示从左上角即(0,0)位置走到(i,j)位置的最小
 * 路径和。对于m的第一行的所有位置来说即(0,j)(0<=j<N)，从(0,0)位置走到(0,j)位置只能向右走，所以(0,0)位置到(0,j)位置的路径和就是m[0][0..j]
 * 这些值的累加结果。同理，对于m的第一列的所有位置来说即(i,0)(0<=i<M)，从(0,0)位置走到(i,0)位置只能向下走，多以(0,0)位置到(i,0)位置的路径和
 * 就是m[0..i][0]这些值的累加结果。以题目中的例子来说dp第一行和第一列的值如下：
 * 1  4  9  18
 * 9
 * 14
 * 22
 * 除了第一行和第一列的其他位置(i,j)，都有左边位置(i-1,j)=Min{dp[i-1][j],dp[i][j-1]}+m[i][j]，含义是比较从(0,0)位置开始，经过(i-1,j)位置最
 * 终到达(i,j)的最小路径和经过(i,j-1)位置最终到达(i,j)的最小路径之间，哪条路径的路径和更小。那么更小的路径和就是dp[i][j]的值。以上面例子来说，
 * 最终生成的dp矩阵如下：
 * 1  4  9  18
 * 9  5  8  12
 * 14 5  11 12
 * 22 13 15 12
 * 除了第一行和第一列之外，每一个位置都考虑从左边到达自己的路径和更小还是从上边达到自己的路劲和更小。最右下角的值就是整个问题的答案。如minPathSum1。
 * 
 * 解答二：
 * 基于动态规划的空间压缩算法。假设滚动到矩阵m的第i行，要求一维数组arr[j]，则arr[j-1]就是从左边过来的最短路径和，而还未更新的arr[j]可以看成
 * 从上面过来的最短路径和，比较两者的大小，取较小的值与m[i][j]相加就是arr[j]的更新后的值。
 * 
 * 本题压缩空间的方法几乎可以应用到所有需要二维动态规划表的面试题目，通过一个数组滚动更新的方式无疑节省了大量的空间。没有优化之前，取得某个位
 * 置动态规划值的过程是在矩阵中进行两次寻址，优化后这一过程主需要一次寻址，程序的常数时间也得到了一定程度的加速。但是空间压缩的方法是有局限性
 * 的，本题如果改成"打印具有最小路径和的路径"，那么就不能使用空间压缩的方法。如果类似本题目这种需要二维表的动态规划题目，最终目的是想求最优解
 * 的具体路径，往往需要完整的动态规划表，但如果只是想求最优解的值，则可以使用空间压缩的方法。因为空间压缩的方法是滚动更新的，会覆盖掉之前求解
 * 的值，让求解轨迹变的不可回溯。
 * 
 * @author liangjian
 * @date 2016-01-19
 */
public class MinPath {
	
	//经典动态规划思路，额外空间复杂度O(row*col)
	public static int minPathSum1(int[][] m) {
		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) { // 二维数组的合法性判断
			return 0;
		}
		int row = m.length;
		int col = m[0].length;
		int[][] dp = new int[row][col]; // 记录每个位置的最短路径和
		dp[0][0] = m[0][0];
		for (int i = 1; i < row; i++) { // 第一列
			dp[i][0] = dp[i - 1][0] + m[i][0];
		}
		for (int j = 1; j < col; j++) { // 第一行
			dp[0][j] = dp[0][j - 1] + m[0][j];
		}
		for (int i = 1; i < row; i++) {
			for (int j = 1; j < col; j++) {
				dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + m[i][j]; // 后面元素的计算依赖前面元素的结果（经典动态规划思路）
			}
		}
		return dp[row - 1][col - 1];
	}
	
	//基于动态规划的空间压缩算法，额外空间复杂度O(min(row,col))
	public int minPathSum2(int[][] m) {
		if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
			return 0;
		}
		int more = Math.max(m.length, m[0].length); // 行数与列数较大的那个more
		int less = Math.min(m.length, m[0].length); // 行数与列数较小的那个less
		boolean rowmore = more == m.length; // 行数是不是大于列数，从而决定是按行还是按列滚动更新arr数组
		int[] arr = new int[less]; // 辅助数组的长度仅为行数与列数中的最小值
		arr[0] = m[0][0];
		for (int i = 1; i < less; i++) {
			arr[i] = arr[i - 1] + (rowmore ? m[0][i] : m[i][0]); // 第一行/第一列：后面的元素均由前一个元素最短路径和来决定
		}
		for (int i = 1; i < more; i++) {
			arr[0] = arr[0] + (rowmore ? m[i][0] : m[0][i]); // 每次滚动时数组的第一个元素只有一个选择，单独处理
			for (int j = 1; j < less; j++) {
				arr[j] = Math.min(arr[j - 1], arr[j]) + (rowmore ? m[i][j] : m[j][i]);
			}
		}
		return arr[less - 1];
	}
}
